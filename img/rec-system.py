# -*- coding: utf-8 -*-
"""notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rm_6BQldXL-6UoMSV_BYgIstwuTm90v7

## Import Library
"""

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import MinMaxScaler
from scipy.sparse import hstack
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
import matplotlib.pyplot as plt
import math

"""## Data Loading"""

pd.set_option('display.max_columns', None)
df = pd.read_csv('spotify_songs.csv')
df.head()

"""## Exploratory Data Analysis"""

# Mengetahui Jumlah Data dan Jumlah Fitur
df.shape

# Mengetahui Nama Kolom
df.columns

# Mengetahui Fitur Apa Saja yang Ada dan Tipe Data yang Digunakan
df.info()

# Mendeteksi Missing Value yang Lebih dari 0
df.isnull().sum()[df.isnull().sum() > 0]

# Mengetahui Karakteristik Data dan Distribusi Data Numerik
df.describe()

# Mengetahui Distribusi Jumlah Lagu per Genre
genre_counts = df["playlist_genre"].value_counts().sort_values()

values = genre_counts.values
norm = plt.Normalize(values.min() * 0.9, values.max())
colors = plt.cm.Reds(norm(values))

plt.figure(figsize=(8, 4))
plt.barh(genre_counts.index, values, color=colors)
plt.title("Distribusi Jumlah Lagu per Genre")
plt.xlabel("Jumlah Lagu")
plt.ylabel("Genre")

plt.tight_layout()
plt.show()

# Mengetahui Distribusi Jumlah Lagu per Sub Genre
genre_counts = df["playlist_subgenre"].value_counts().sort_values()

values = genre_counts.values
norm = plt.Normalize(values.min() * 0.9, values.max())
colors = plt.cm.Reds(norm(values))

plt.figure(figsize=(12, 6))
plt.barh(genre_counts.index, values, color=colors)
plt.title("Distribusi Jumlah Lagu per Sub Genre")
plt.xlabel("Jumlah Lagu")
plt.ylabel("Genre")

plt.tight_layout()
plt.show()

# Untuk Mengetahui Korelasi Antar Fitur dengan Correlation Matrix
audio_features = [
    "danceability", "energy", "key", "loudness", "mode",
    "speechiness", "acousticness", "instrumentalness",
    "liveness", "valence", "tempo"
]

corr_matrix = df[audio_features].corr()

plt.figure(figsize=(10, 8))
im = plt.imshow(corr_matrix, aspect="auto")

plt.colorbar(im, fraction=0.046, pad=0.04)
plt.xticks(range(len(audio_features)), audio_features, rotation=45, ha="right")
plt.yticks(range(len(audio_features)), audio_features)
plt.title("Heatmap Korelasi Fitur Audio Lagu Spotify")

plt.tight_layout()
plt.show()

"""## Data Preparation"""

# Fungsi Untuk Cleaning Data dan Memilih Fitur yang Relevan Dengan Use Case (Feature Selection)
def cleaning(df):
    df.dropna(inplace = True)
    df = df[['track_artist', 'playlist_genre', 'playlist_subgenre', 'danceability', 'energy', 'key', 'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'duration_ms']]

    return df

# Fungsi untuk Preprocessing Data
def preprocessing(df):

    # Splitting Berdasarkan Tipe Data
    df_num = df.select_dtypes(include = 'number')
    df_obj = df['track_artist'] + ' ' + df['playlist_genre'] + ' ' + df['playlist_subgenre']

    # Scaling dengan MinMax Scaler
    scaler = MinMaxScaler()
    arr_1 = scaler.fit_transform(df_num)

    df_num_scaled = pd.DataFrame(df_num, columns = df_num.columns) # Transformasi Array Menjadi Bentuk Dataframe
    df_num_scaled['content'] = df_obj # Membuat Kolom Baru Bernama content dan Menambahkan Data dari df_obj

    df_final = df_num_scaled # Dataframe Final Setelah Preprocessing

    return df_final, arr_1

# Ekstraksi Fitur teks dengan TF-IDF (Feature Extraction)
def vectorize(df):
    df_obj = df.content
    tfidf = TfidfVectorizer(max_features = 5000, stop_words = None)
    arr_2 = tfidf.fit_transform(df_obj)

    return arr_2

# Menjalankan Semua Fungsi
df_clean = cleaning(df)
df_preprocessing, arr_1 = preprocessing(df_clean)
vector = vectorize(df_preprocessing)

display(df_clean.head())
display(df_preprocessing.head())

vector

"""## Modelling & Evaluation"""

X = hstack([vector, arr_1])
X = X.tocsr()

nn = NearestNeighbors(
    metric="cosine",
    algorithm="brute"
)
nn.fit(X)

def recommendation(song_name, df, X, nn, top_k=5, cols=None, user_artist=None, sim_threshold=0.85, total_relevant=None):
    idx_query = df.index[df['track_name'] == song_name][0]
    query_vector = X[idx_query]

    if len(query_vector.shape) == 1:
        query_vector = query_vector.reshape(1, -1)  # (1, n_features)

    distances, indices = nn.kneighbors(query_vector, n_neighbors=top_k+1)
    recommended_idx = indices[0][1:]

    rec_df = df.iloc[recommended_idx].copy()

    if user_artist is None:
        user_artist = df.loc[idx_query, "track_artist"]
    user_genre = df.loc[idx_query, "playlist_genre"]

    if "similarity" not in rec_df.columns:
        rec_df["similarity"] = 1 - distances[0][1:]

    # Fungsi Graded Relevance
    def relevance_score(row):
        if row["playlist_genre"] == user_genre and row["track_artist"] == user_artist:
            return 2
        elif row["playlist_genre"] == user_genre or row["similarity"] >= sim_threshold:
            return 1
        else:
            return 0

    rec_df["graded_rel"] = rec_df.apply(relevance_score, axis=1)

    # Precision@K
    precision = sum(rec_df["graded_rel"] > 0) / top_k

    # Recall@K
    if total_relevant is None:
        total_relevant = top_k
    recall = sum(rec_df["graded_rel"] > 0) / total_relevant

    # NDCG@K
    def ndcg(scores):
        dcg = sum([(2**rel - 1)/math.log2(idx + 2) for idx, rel in enumerate(scores)])
        ideal = sorted(scores, reverse=True)
        idcg = sum([(2**rel - 1)/math.log2(idx + 2) for idx, rel in enumerate(ideal)])
        return dcg / idcg if idcg > 0 else 0

    ndcg_score = ndcg(rec_df["graded_rel"].tolist())

    if cols:
        rec_df = rec_df[cols + ["graded_rel", "similarity"]]

    metrics = {
        "Precision@K": precision,
        "Recall@K": recall,
        "NDCG@K": ndcg_score
    }

    return rec_df, metrics

rekomendasi, metrik = recommendation(
    song_name="Animal",
    df=df,
    X=X,
    nn=nn,
    top_k=5,
    cols=["track_name", "track_artist", "playlist_genre"]
)

print(rekomendasi)
print(metrik)

# Fungsi untuk Rekomendasi Lagu Berdasarkan Index Popularity
def popularity_recommendation(df, top_k, cols=None):
    df_unique = (
        df.groupby(["track_name", "track_artist"], as_index=False)
          .agg({
              "track_popularity": "max",
              "playlist_genre": "first"
          })
    )

    result = df_unique.sort_values(
        by="track_popularity",
        ascending=False
    ).head(top_k)

    if cols is not None:
        result = result[cols]

    return result

popularity_recommendation(
    df,
    top_k=5,
    cols=[
        "track_name",
        "track_artist",
        "playlist_genre",
        "track_popularity"
    ]
)

